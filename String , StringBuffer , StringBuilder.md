## String , StringBuffer , StringBuilder 

### String 

> `` String ``  看起来很简单，但这部分是 ``JAVA``  非常基础非常重要的一部分，那么 ，你是否思考过你一直在使用的 ``String``  是什么呢？

``String `` 是 ``Java``  提供了字符串构造和管理字符串各种的一个类，他是一个 `` immutable ``  (不可改) 的类，被定义为 ``final class `` ，其所有的属性也是 ``final``  。由于它的不可变性，所以它所有的操作，如裁剪，拼接都会导致新 `` String`` 对象的产生。

在面试中经常会有一个这样的问题：``String`` 为什么要定义成 ``final`` ？

1. 定义为 ``final``  则 ``String`` 是 ``immutable`` （不可变）类，那么，``String`` 天生就是线程安全的，因为不可变，所以在读写的时候，无法在同一个对象进行读写，所以是线程安全的。
2. 因为 ``String`` 是在程序中的应用非常广泛，所以我们必须保证 ``String`` 是安全的，不会被轻易被修改的，比如我们当作一个 ``map`` 的 ``key`` ，如果被随便可改变的话，那么就会非常危险。

 更多关于 ``immutable`` 的好处可以看这个连接：http://mindprod.com/jgloss/immutable.html

### StringBuffer 

``StringBuffer`` 是为了解决字符串操作会产生多余对象的一个类，我们可以通过 `` append`` , ``add`` 等方法对字符串进行拼接。当然，``StringBuffer`` 也提供了很多其他的方法对字符串进行操作，这些操作也都是线程安全的，不过，也正因为保证了线程安全，所以 ``StringBuffer``  也会带来多余的额外开销。如果不需要保证线程安全，推荐使用 ``StringBuilder`` 。

查看了源码就知道，与 ``String`` 天生就拥有线程安全的能力不同，``StringBuffer`` 保证线程安全的方法异常粗暴，就是在每个方法都加上 ``synchronized``  进行加锁，强行保证线程安全，其实这样不必纠结于性能的加锁方法非常适合我们平时实现线程安全的类，因为过早的进行性能优化，反而不是一个好事，程序易读，可靠，且能实现功能，才是一个好程序应有的表现，只有当出现性能瓶颈才需要考虑过多的性能优化。

### StringBuilder

``StringBuilder``  是一个和 ``StringBuffer`` 功能相近的类，他们都继承于 `` AbstractStringBuilder`` 所以他们拥有相同的对字符串操作的表现，唯一的区别就是去掉了线程安全，减少了性能开销，因此，如果需要进行字符串的拼接，大部分情况首选 ``StringBuilder`` 。 

那么，``StringBuilder``  和 ``StringBuffer``  内部存储的数组是多大呢？目前的实现是字符串的 **原始长度+16**  如果我们进行拼接的次数很多，而且数据的大小可以预估的，那我们可以一开始指定大小，减少扩容带来的损耗，因为我们知道，扩容是需要新建数组和搬运数组的，这将会带来额外的开销。 

**如果不是频繁的进行拼接操作的话，建议直接使用 + 号拼接，而如果频繁的拼接的话，建议使用 StringBuilder  进行拼接，这会节省很多开销，因为 + 号拼接会生成一些中间无用的对象，减少内存和性能的开销**

### 字符串缓存

如果你开发过一个程序，你会发现，在程序中字符串占了大部分，有人统计过，用 ``Java`` 开发的应用中，字符串占了 25% 以上， 而且其中有大半部分是重复的，那么基于性能考虑，我们肯定是想这些重复的字符串是否可以重复利用，避免重新创建，节省开销和内存消耗。这就要用到我们所谓的 **字符串常量池 **了。

在创建的时候我们有两种方法：

#### 1. String 直接赋值

以下方法将 aa 先在常量池中查找，如果有的话返回一个引用给 str ，如果没有的话直接放到字符串常量池中，并返回一个引用

```java
String str = "aa"; 
```

这种方法创建方法可以直接使用字符串常量池。

#### 2. new String()

我们也会通过直接 ``new`` 来创建一个 ``String`` 

```java
String str = new String ("aa");
```

这种创建方是会直接生成一个对象放在堆，然后再直接返回一个引用给 str ，这种方式就不会通过字符串常量池进行优化，那么，如果我们需要用这种方是，还需要在常量池进行复用呢？ 

在 ``Java6`` 时，``String``  提供了 ``intern`` 方法，该方法是在 ``Jvm`` 层面进行字符串缓存 ``Jvm`` 会对类似 ``abc`` 之类的文本进行缓存，如果下次需要用到 ``abc`` 之类的文本，则会从缓存中获取，然后重用。但是这种方是也有个副作用，就是必须显示调用，你必须显示在每个字符串显示调用 ``intern `` 方法。这种方法是非常麻烦的。因为我们在开发过程中并无法知道字符串的重用程度，这样显示调用，反而降低了开发效率。甚至造成了一定的代码污染。

在 ``Oracle JDK 8u20 `` 后推出了一个新特性，就是在 ``G1 GC``  (G1 GC 是一种采用复合算法的 GC) 下的字符排重，在 GC 的时候将指向相同字符串（不同实例）的引用指向同一个字符串引用，这是 ``JVM`` 底层的改变，并不需要开发者额外做什么修改。这个功能默认是关闭的，需要调用 ``JVM`` 参数进行打开：

```java
-XX:+UseStringDeduplication
```



综上，虽然字符串看起来非常简单，但是其中的奥妙依然不少，适当选择不同的字符串操作类，来为性能锦上添花把。